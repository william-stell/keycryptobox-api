import { ed25519 } from "@noble/curves/ed25519";
import { secp256k1 } from "@noble/curves/secp256k1";
import { p256 } from "@noble/curves/p256";

import type { KeyType } from "../types";

import { bytesToHex, hexToBytes } from "@noble/hashes/utils";

export interface KeyTypeData {
  description: string;
  lib: typeof ed25519 | typeof secp256k1 | typeof p256;
}

const keyTypesData: Record<KeyType, KeyTypeData> = {
  ed25519: {
    description:
      "Fast, deterministic signatures with strong security; used in Signal, Monero, Stellar, Cardano, and SSH.",
    lib: ed25519,
  },
  secp256k1: {
    description:
      "Widely used in Bitcoin, Ethereum, and Litecoin; optimized for fast multiplication and popular in blockchain applications.",
    lib: secp256k1,
  },
  secp256r1: {
    description:
      "Most widely used NIST curve, common in TLS/SSL and government standards.",
    lib: p256,
  },
};

export function isSupportedKeyType(keyType: string): keyType is KeyType {
  return keyType in keyTypesData;
}

export function getSupportedKeyTypes() {
  return Object.entries(keyTypesData).map(([name, { description }]) => ({
    name,
    description,
  }));
}

/**
 * Generates a cryptographic key pair based on the specified key type.
 *
 * @param keyType - The type of key to generate, corresponding to a supported `KeyType`.
 *                  This determines the algorithm and key format used.
 *
 * @precondition The `keyType` must be a valid key type supported by `keyTypesData`.
 *               This function uses `isSupportedKeyType` to validate the input at runtime.
 *
 * @returns A key pair generated by the method associated with the given `keyType`.
 *
 * @throws Will throw an error if the provided `keyType` is not supported or if key generation fails.
 *
 * @example
 * ```ts
 * if (isSupportedKeyType("ed25519")) {
 *   const keyPair = generateKeyPair("ed25519");
 *   console.log(keyPair.publicKey, keyPair.privateKey);
 * }
 * ```
 */
export function generateKeyPair(keyType: KeyType) {
  if (!isSupportedKeyType(keyType)) {
    throw new Error(`Invalid keyType: ${keyType}`);
  }

  const lib = keyTypesData[keyType].lib;

  const privateKeyRaw = lib.utils.randomPrivateKey();
  const publicKeyRaw = lib.getPublicKey(privateKeyRaw);
  return {
    privateKey: bytesToHex(privateKeyRaw),
    publicKey: bytesToHex(publicKeyRaw),
  };
}

/**
 * Signs a message (hex-encoded) using a hex-encoded private key.
 *
 * @param keyType - The key algorithm (e.g., 'ed25519', 'secp256k1').
 * @param privateKey - Private key as a hex string.
 * @param message - Message to sign, as a hex string.
 * @returns Signature as a hex string.
 * @throws If the key type is not supported or inputs are invalid.
 */
export function sign(
  keyType: KeyType,
  privateKey: string,
  message: string
): string {
  if (!isSupportedKeyType(keyType)) {
    throw new Error(`Invalid keyType: ${keyType}`);
  }

  const privateKeyBytes: Uint8Array = hexToBytes(privateKey);
  const messageBytes: Uint8Array = hexToBytes(message);

  const lib = keyTypesData[keyType].lib;
  const sig = lib.sign(messageBytes, privateKeyBytes);

  if (sig.toCompactHex) {
    return sig.toCompactHex();
  }

  return bytesToHex(sig);
}

/**
 * Verifies a base64-encoded signature for a hex-encoded message and hex-encoded public key.
 *
 * @param keyType - The key algorithm (e.g., 'ed25519', 'secp256k1').
 * @param publicKey - Public key as a hex string.
 * @param message - Message that was signed, as a hex string.
 * @param signature - Signature as a hex string.
 * @returns True if the signature is valid, false otherwise.
 * @throws If the key type is not supported or inputs are invalid.
 */
export function verify(
  keyType: KeyType,
  publicKey: string,
  message: string,
  signature: string
): boolean {
  if (!isSupportedKeyType(keyType)) {
    throw new Error(`Invalid keyType: ${keyType}`);
  }

  const publicKeyBytes = hexToBytes(publicKey);
  const messageBytes = hexToBytes(message);
  const signatureBytes = hexToBytes(signature);

  const lib = keyTypesData[keyType].lib;
  return lib.verify(signatureBytes, messageBytes, publicKeyBytes);
}
